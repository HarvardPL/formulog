(* An algebraic data type with a single variant *)
type basic_typ =
    | b_int
    | b_bool

(* A type alias *)
type var = string

(* For the sake of simplicity, we'll support just a few operations *)
type op =
    | o_add
    | o_eq

type pred =
    | p_var(var)
    | p_bool(bool)
    (* i32 is the type of a 32-bit signed integer *)
    | p_int(i32)
    | p_interp_op(op, pred, pred)
    | p_conj(pred, pred)
    | p_disj(pred, pred)
    | p_neg(pred)
    | p_ite(pred, pred, pred)

type constraint =
    | c_pred(pred)
    | c_conj(constraint, constraint)
    | c_imp(var, basic_typ, pred, constraint)

type typ =
    | t_refined(basic_typ, var, pred)
    | t_func(var, typ, typ)

type kind =
    | k_base
    | k_star

(* Tuples and lists are built-in type *)
type env = (var * typ) list

rel wf(env, typ, kind)

wf(G, T, k_star) :- wf(G, T, k_base).

wf(G, t_func(X, S, T), k_star) :-
    wf(G, S, _Ks),
    wf((X, S) :: G, T, _Kt).

rel pred_wf(env, pred, basic_typ)

pred_wf(_E, p_bool(_B), b_bool).

pred_wf(_E, p_int(_I), b_int).

pred_wf(E, p_interp_op(o_add, P1, P2), b_int) :-
    pred_wf(E, P1, b_int),
    pred_wf(E, P2, b_int).

pred_wf(E, p_interp_op(o_eq, P1, P2), b_bool) :-
    pred_wf(E, P1, T),
    pred_wf(E, P2, T).

(* We can define a Horn clause with two heads, meaning both conclusions hold *)
pred_wf(E, p_conj(P1, P2), b_bool),
pred_wf(E, p_disj(P1, P2), b_bool) :-
    pred_wf(E, P1, b_bool),
    pred_wf(E, P2, b_bool).

pred_wf(E, p_neg(P), b_bool) :-
    pred_wf(E, P, b_bool).

pred_wf(E, p_ite(P1, P2, P3), T) :-
    pred_wf(E, P1, b_bool),
    pred_wf(E, P2, T),
    pred_wf(E, P3, T).

fun lookup(x: var, e: env): typ option =
    match e with
    | [] => none
    | (y, t) :: rest => if x = y then some(t) else lookup(x, rest)
    end

pred_wf(E, p_var(V), B) :-
    lookup(V, E) = some(t_refined(B, _, _)).

wf(G, t_refined(B, V, P), k_base) :-
    K = (V, t_refined(B, V, p_bool(true))),
    pred_wf(K :: G, P, b_bool).

:- pred_wf([], p_bool(true), b_bool).

type val =
    | v_int(int)
    | v_bool(bool)

fun pred2smt(p: pred): val smt =
    match p with
    | p_bool(b) => `v_bool(b)`
    | p_conj(p1, p2) =>
        let v1 = pred2smt(p1) in
        let v2 = pred2smt(p2) in
        `v_bool(#v_bool_1(v1) /\ #v_bool_1(v2))`
    | p_disj(p1, p2) =>
        let v1 = pred2smt(p1) in
        let v2 = pred2smt(p2) in
        `v_bool(#v_bool_1(v1) \/ #v_bool_1(v2))`
    | p_neg(p1) =>
        let v1 = pred2smt(p1) in
        `v_bool(~#v_bool_1(v1))`
    | p_int(n) => `v_int(int_const(n))`
    | p_interp_op(o, p1, p2) =>
        let v1 = pred2smt(p1) in
        let v2 = pred2smt(p2) in
        match o with
        | o_eq => `v_bool(v1 #= v2)`
        | o_add => `v_int(int_add(#v_int_1(v1), #v_int_1(v2)))`
        end
    | p_ite(p1, p2, p3) =>
        let v1 = pred2smt(p1) in
        let v2 = pred2smt(p2) in
        let v3 = pred2smt(p3) in
        `#if #v_bool_1(v1) then v2 else v3`
    | p_var(x) => `#{x}[val]`
    end

fun constraint2smt(c: constraint): bool smt =
    match c with
    | c_conj(c1, c2) =>
        let s1 = constraint2smt(c1) in
        let s2 = constraint2smt(c2) in
        `s1 /\ s2`
    | c_pred(p) => let s = pred2smt(p) in `#v_bool_1(s)`
    | c_imp(x, _b, p1, c1) =>
        (* Note that we do not actually need to use the basic type `_b` *)
        let prem = pred2smt(p1) in
        let conl = constraint2smt(c1) in
        `forall #{x}[val]. #v_bool_1(prem) ==> conl`
    end

rel ent(env, constraint)

ent([], C) :- is_valid(constraint2smt(C)).

ent((X, t_refined(B, X, P)) :: G, C) :-
    ent(G, c_imp(X, B, P, C)).

fun subst_pred(p: pred, y: var, z: var): pred =
    match p with
    | p_bool(_) | p_int(_) => p
    | p_var(x) => p_var(if x = y then z else x)
    | p_interp_op(o, p1, p2) =>
        let p1 = subst_pred(p1, y, z) in
        let p2 = subst_pred(p2, y, z) in
        p_interp_op(o, p1, p2)
    | p_disj(p1, p2) =>
        let p1 = subst_pred(p1, y, z) in
        let p2 = subst_pred(p2, y, z) in
        p_disj(p1, p2)
    | p_conj(p1, p2) =>
        let p1 = subst_pred(p1, y, z) in
        let p2 = subst_pred(p2, y, z) in
        p_conj(p1, p2)
    | p_neg(p1) => 
        let p1 = subst_pred(p1, y, z) in
        p_neg(p1)
    | p_ite(p1, p2, p3) =>
        let p1 = subst_pred(p1, y, z) in
        let p2 = subst_pred(p2, y, z) in
        let p3 = subst_pred(p3, y, z) in
        p_ite(p1, p2, p3)
    end

fun subst_typ(t: typ, y: var, z: var): typ =
    match t with
    | t_refined(b, v, p) =>
        if v = y then t else t_refined(b, v, subst_pred(p, y, z)) 
    | t_func(x, s, t) =>
        let s = subst_typ(s, y, z) in
        let t = if x = y then t else subst_typ(t, y, z) in
        t_func(x, s, t)
    end

